#include "SEGGER_SYSVIEW.h"

#if (SEGGER_UART_REC == 1)
#include "SEGGER_RTT.h"
#include "stm32f7xx.h"

#define OS_FSYS 216000000L   // Frecuencia principal del STM32F767
#define RCC_BASE_ADDR       0x40023800

#define OFF_AHB1ENR         0x30        // AHB1 peripheral clock enable register
#define OFF_APB1ENR         0x40        // APB1 peripheral clock enable register
#define OFF_APB2ENR         0x44        // APB2 peripheral clock enable register

#define RCC_AHB1ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_AHB1ENR)
#define RCC_APB1ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_APB1ENR)
#define RCC_APB2ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_APB2ENR)

#define GPIOD_BASE_ADDR     0x40020C00

#define OFF_MODER           0x00        // GPIOx_MODER    (GPIO port mode register)
#define OFF_AFRL            0x20        // GPIOx_AFRL     (GPIO alternate function low register)
#define OFF_AFRH            0x24        // GPIOx_AFRH     (GPIO alternate function high register)

#define USART3_BASE_ADDR    0x40004800

#define OFF_SR              0x00        // Status register
#define OFF_DR              0x04        // Data register
#define OFF_BRR             0x08        // Baudrate register
#define OFF_CR1             0x0C        // Control register 1
#define OFF_CR2             0x10        // Control register 2
#define OFF_CR3             0x14        // Control register 3

#define UART_BASECLK        OS_FSYS / 4  // USART3 corre en APB1 clock
#define GPIO_BASE_ADDR      GPIOD_BASE_ADDR
#define USART_BASE_ADDR     USART3_BASE_ADDR
#define GPIO_UART_TX_BIT    8           // USART3 TX: Pin PD8
#define GPIO_UART_RX_BIT    9           // USART3 RX: Pin PD9
#define USART_IRQn          USART3_IRQn

#define GPIO_MODER          *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_MODER)
#define GPIO_AFRL           *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_AFRL)
#define GPIO_AFRH           *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_AFRH)

#define USART_SR            *(volatile uint32_t*)(USART_BASE_ADDR + OFF_SR)
#define USART_DR            *(volatile uint32_t*)(USART_BASE_ADDR + OFF_DR)
#define USART_BRR           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_BRR)
#define USART_CR1           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR1)
#define USART_CR2           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR2)
#define USART_CR3           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR3)

#define USART_RXNE              5     // Registro de datos RX no vacío (SR)
#define USART_TC                6     // Transmisión completa (SR)
#define USART_RX_ERROR_FLAGS  0xB     // Flags de error de paridad, marco, sobrecarga (SR)
#define USART_RXNEIE            5     // Habilitar interrupción de RX (CR1)
#define USART_TCIE              6     // Habilitar interrupción de transmisión completa (CR1)
#define USART_TXE               7     // Registro de datos TX vacío
#define USART_TXEIE             7     // Habilitar interrupción de registro TX vacío

typedef void UART_ON_RX_FUNC(uint8_t Data);
typedef int  UART_ON_TX_FUNC(uint8_t* pChar);

typedef UART_ON_TX_FUNC* UART_ON_TX_FUNC_P;
typedef UART_ON_RX_FUNC* UART_ON_RX_FUNC_P;

static UART_ON_RX_FUNC_P _cbOnRx;
static UART_ON_TX_FUNC_P _cbOnTx;

void HIF_UART_Init(uint32_t Baudrate, UART_ON_TX_FUNC_P cbOnTx, UART_ON_RX_FUNC_P cbOnRx);
void HIF_UART_WaitForTxEnd(void);
void HIF_UART_EnableTXEInterrupt(void);
void USART3_IRQHandler(void);

#define _SERVER_HELLO_SIZE        (4)
#define _TARGET_HELLO_SIZE        (4)

static const uint8_t _abHelloMsg[_TARGET_HELLO_SIZE] = { 'S', 'V', (SEGGER_SYSVIEW_VERSION / 10000), (SEGGER_SYSVIEW_VERSION / 1000) % 10 };

static struct {
  uint8_t  NumBytesHelloRcvd;
  uint8_t  NumBytesHelloSent;
  int      ChannelID;
} _SVInfo = {0,0,1};

static void _StartSysView(void) {
  if (!SEGGER_SYSVIEW_IsStarted()) {
    SEGGER_SYSVIEW_Start();
  }
}

static void _cbOnUARTRx(uint8_t Data) {
  if (_SVInfo.NumBytesHelloRcvd < _SERVER_HELLO_SIZE) {
    _SVInfo.NumBytesHelloRcvd++;
  } else {
    _StartSysView();
    SEGGER_RTT_WriteDownBuffer(_SVInfo.ChannelID, &Data, 1);
  }
}

static int _cbOnUARTTx(uint8_t* pChar) {
  int r;

  if (_SVInfo.NumBytesHelloSent < _TARGET_HELLO_SIZE) {
    *pChar = _abHelloMsg[_SVInfo.NumBytesHelloSent++];
    return 1;
  }
  r = SEGGER_RTT_ReadUpBufferNoLock(_SVInfo.ChannelID, pChar, 1);
  return (r < 0) ? 0 : r;
}

void SEGGER_UART_init(uint32_t baud) {
  HIF_UART_Init(baud, _cbOnUARTTx, _cbOnUARTRx);
}

void HIF_UART_WaitForTxEnd(void) {
  while ((USART_SR & (1 << USART_TXE)) == 0);
  while ((USART_SR & (1 << USART_TC)) == 0);
}

void USART3_IRQHandler(void) {
  int UsartStatus;
  uint8_t v;
  //int r;

  UsartStatus = USART_SR;
  if (UsartStatus & (1 << USART_RXNE)) {
    v = USART_DR;
    if (!(UsartStatus & USART_RX_ERROR_FLAGS) && _cbOnRx) {
      _cbOnRx(v);
    }
  }
  if (UsartStatus & (1 << USART_TXE)) {
    if (_cbOnTx && _cbOnTx(&v) == 1) {
      USART_DR = v;
    } else {
      USART_CR1 &= ~(1UL << USART_TXEIE);
    }
  }
}

void HIF_UART_EnableTXEInterrupt(void) {
  USART_CR1 |= (1 << USART_TXEIE);
}

void HIF_UART_Init(uint32_t Baudrate, UART_ON_TX_FUNC_P cbOnTx, UART_ON_RX_FUNC_P cbOnRx) {
  uint32_t v;
  uint32_t Div;

  RCC_APB1ENR |= (1 << 18);        // Habilitar reloj USART3 (APB1)
  RCC_AHB1ENR |= (1 << 3);         // Habilitar reloj GPIOD

  v  = GPIO_AFRH;
  v &= ~((15UL << ((GPIO_UART_TX_BIT - 8) * 4)) | (15UL << ((GPIO_UART_RX_BIT - 8) * 4)));
  v |=  ((7UL << ((GPIO_UART_TX_BIT - 8) * 4)) | (7UL << ((GPIO_UART_RX_BIT - 8) * 4)));
  GPIO_AFRH = v;

  v  = GPIO_MODER;
  v &= ~((3UL << (GPIO_UART_TX_BIT * 2)) | (3UL << (GPIO_UART_RX_BIT * 2)));
  v |=  ((2UL << (GPIO_UART_TX_BIT * 2)) | (2UL << (GPIO_UART_RX_BIT * 2)));
  GPIO_MODER = v;

  USART_CR1 = (1 << 15) | (1 << 13) | (1 <<  5) | (1 <<  3) | (1 <<  2);
  USART_CR2 = 0;
  USART_CR3 = 0;

  Div = ((2 * (UART_BASECLK)) / (Baudrate * 8)) + 1;
  Div = (Div / 2) & 0xFFF;
  USART_BRR = Div << 4;

  _cbOnRx = cbOnRx;
  _cbOnTx = cbOnTx;
  NVIC_SetPriority(USART_IRQn, 6);
  NVIC_EnableIRQ(USART_IRQn);
}

#endif

