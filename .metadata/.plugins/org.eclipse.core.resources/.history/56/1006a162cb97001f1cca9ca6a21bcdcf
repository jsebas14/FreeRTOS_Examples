#include "SEGGER_SYSVIEW.h"

#if (SEGGER_UART_REC == 1)
#include "SEGGER_RTT.h"
#include "stm32f7xx.h"

#define OS_FSYS 216000000L   // MCU core frequency del STM32F767
#define RCC_BASE_ADDR       0x40023800

#define OFF_AHB1ENR         0x30        // AHB1 peripheral clock enable register
#define OFF_APB1ENR         0x40        // APB1 peripheral clock enable register
#define OFF_APB2ENR         0x44        // APB2 peripheral clock enable register

#define RCC_AHB1ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_AHB1ENR)
#define RCC_APB1ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_APB1ENR)
#define RCC_APB2ENR         *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_APB2ENR)

#define GPIOD_BASE_ADDR     0x40020C00  // Dirección base de GPIO D para PD8 y PD9

#define OFF_MODER           0x00        // GPIOx_MODER    (GPIO port mode register)
#define OFF_AFRL            0x20        // GPIOx_AFRL     (GPIO alternate function low register)
#define OFF_AFRH            0x24        // GPIOx_AFRH     (GPIO alternate function high register)

#define USART3_BASE_ADDR    0x40004800  // Base de USART3

#define OFF_SR              0x00        // Status register
#define OFF_DR              0x04        // Data register
#define OFF_BRR             0x08        // Baudrate register
#define OFF_CR1             0x0C        // Control register 1
#define OFF_CR2             0x10        // Control register 2
#define OFF_CR3             0x14        // Control register 3

#define UART_BASECLK        OS_FSYS / 4 // USART3 en APB1 clock
#define GPIO_BASE_ADDR      GPIOD_BASE_ADDR
#define USART_BASE_ADDR     USART3_BASE_ADDR
#define GPIO_UART_TX_BIT    8           // USART3 TX: Pin PD8
#define GPIO_UART_RX_BIT    9           // USART3 RX: Pin PD9
#define USART_IRQn          USART3_IRQn

#define GPIO_MODER          *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_MODER)
#define GPIO_AFRL           *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_AFRL)
#define GPIO_AFRH           *(volatile uint32_t*)(GPIO_BASE_ADDR + OFF_AFRH)

#define USART_SR            *(volatile uint32_t*)(USART_BASE_ADDR + OFF_SR)
#define USART_DR            *(volatile uint32_t*)(USART_BASE_ADDR + OFF_DR)
#define USART_BRR           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_BRR)
#define USART_CR1           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR1)
#define USART_CR2           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR2)
#define USART_CR3           *(volatile uint32_t*)(USART_BASE_ADDR + OFF_CR3)

// Macros y funciones adicionales aquí...

void HIF_UART_Init(uint32_t Baudrate, UART_ON_TX_FUNC_P cbOnTx, UART_ON_RX_FUNC_P cbOnRx) {
  uint32_t v;
  uint32_t Div;

  // Habilitar reloj de USART3 y puerto D
  RCC_APB1ENR |= (1 << 18);       // Habilitar reloj USART3 (APB1)
  RCC_AHB1ENR |= (1 << 3);        // Habilitar reloj GPIO D

  // Configurar los pines PD8 y PD9 para función alternativa AF7 (USART3)
  v  = GPIO_AFRH;
  v &= ~((15UL << ((GPIO_UART_TX_BIT - 8) * 4)) | (15UL << ((GPIO_UART_RX_BIT - 8) * 4)));
  v |=  ((7UL << ((GPIO_UART_TX_BIT - 8) * 4)) | (7UL << ((GPIO_UART_RX_BIT - 8) * 4)));
  GPIO_AFRH = v;

  // Configurar pines como función alternativa
  v  = GPIO_MODER;
  v &= ~((3UL << (GPIO_UART_TX_BIT * 2)) | (3UL << (GPIO_UART_RX_BIT * 2)));
  v |=  ((2UL << (GPIO_UART_TX_BIT * 2)) | (2UL << (GPIO_UART_RX_BIT * 2)));
  GPIO_MODER = v;

  // Inicializar USART3
  USART_CR1 = 0
            | (1 << 15)  // OVER8 = 1; Oversampling por 8
            | (1 << 13)  // UE = 1; Habilitar USART
            | (0 << 12)  // M = 0; 1 bit de start, 8 bits de datos
            | (0 << 10)  // PCE = 0; Sin control de paridad
            | (1 <<  5)  // RXNEIE = 1; Interrupción RX habilitada
            | (1 <<  3)  // TE = 1; Transmisor habilitado
            | (1 <<  2); // RE = 1; Receptor habilitado

  USART_CR2 = 0;  // STOP = 00b; 1 bit de stop
  USART_CR3 = 0;  // ONEBIT = 0; Método de 3 muestras

  // Configurar baudrate
  Div = Baudrate * 8; // Uso de oversampling x8
  Div = ((2 * (UART_BASECLK)) / Div) + 1;
  Div = Div / 2;
  if (Div > 0xFFF) {
    Div = 0xFFF;
  }
  USART_BRR = 0xFFF0 & (Div << 4);

  // Configuración de callbacks y habilitar interrupciones NVIC
  _cbOnRx = cbOnRx;
  _cbOnTx = cbOnTx;
  NVIC_SetPriority(USART_IRQn, 6);
  NVIC_EnableIRQ(USART_IRQn);
}
#endif

