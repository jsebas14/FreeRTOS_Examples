#include "SEGGER_SYSVIEW.h"
#include "stm32f7xx.h"

#define OS_FSYS 216000000L   // Frecuencia del núcleo para STM32F767

// Definiciones de direcciones y offsets de registros
#define RCC_BASE_ADDR        0x40023800
#define OFF_AHB1ENR          0x30        // AHB1 peripheral clock enable register
#define OFF_APB1ENR          0x40        // APB1 peripheral clock enable register
#define RCC_AHB1ENR          *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_AHB1ENR)
#define RCC_APB1ENR          *(volatile uint32_t*)(RCC_BASE_ADDR + OFF_APB1ENR)

#define GPIOD_BASE_ADDR      0x40020C00
#define OFF_MODER            0x00        // GPIOx_MODER (GPIO port mode register)
#define OFF_AFRL             0x20        // GPIOx_AFRL (GPIO alternate function low register)
#define OFF_AFRH             0x24        // GPIOx_AFRH (GPIO alternate function high register)
#define GPIO_MODER           *(volatile uint32_t*)(GPIOD_BASE_ADDR + OFF_MODER)
#define GPIO_AFRL            *(volatile uint32_t*)(GPIOD_BASE_ADDR + OFF_AFRL)
#define GPIO_AFRH            *(volatile uint32_t*)(GPIOD_BASE_ADDR + OFF_AFRH)

#define USART3_BASE_ADDR     0x40004800
#define OFF_CR1              0x00        // Control register 1
#define OFF_CR2              0x04        // Control register 2
#define OFF_CR3              0x08        // Control register 3
#define OFF_BRR              0x0C        // Baudrate register
#define OFF_SR               0x1C        // Status register
#define OFF_TDR              0x28        // Data register for TX
#define OFF_RDR              0x24        // Data register for RX
#define USART_SR             *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_SR)
#define USART_BRR            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_BRR)
#define USART_CR1            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_CR1)
#define USART_CR2            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_CR2)
#define USART_CR3            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_CR3)
#define USART_RDR            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_RDR)
#define USART_TDR            *(volatile uint32_t*)(USART3_BASE_ADDR + OFF_TDR)

// Configuración de flags y bits de USART
#define UART_BASECLK         OS_FSYS / 4  // USART3 corre en el reloj APB1
#define GPIO_UART_TX_BIT     8            // USART3 TX: Pin PD8
#define GPIO_UART_RX_BIT     9            // USART3 RX: Pin PD9
#define USART_IRQn           USART3_IRQn
#define USART_RXNE           5            // Read data register not empty flag (SR)
#define USART_TC             6            // Transmission complete flag (SR)
#define USART_RX_ERROR_FLAGS 0xB          // Parity, framing, overrun error flags (SR)
#define USART_RXNEIE         5            // Read data register not empty interrupt enable (CR1)
#define USART_TCIE           6            // Transmission complete interrupt enable (CR1)
#define USART_TXE            7            // Transmit data register empty
#define USART_TXEIE          7            // Transmit data register empty interrupt enable

// Definición de funciones de callback
typedef void UART_ON_RX_FUNC(uint8_t Data);
typedef int  UART_ON_TX_FUNC(uint8_t* pChar);

typedef UART_ON_TX_FUNC* UART_ON_TX_FUNC_P;
typedef UART_ON_RX_FUNC* UART_ON_RX_FUNC_P;

static UART_ON_RX_FUNC_P _cbOnRx;
static UART_ON_TX_FUNC_P _cbOnTx;

// Prototipos
void HIF_UART_Init(uint32_t Baudrate, UART_ON_TX_FUNC_P cbOnTx, UART_ON_RX_FUNC_P cbOnRx);
void HIF_UART_EnableTXEInterrupt(void);
void SEGGER_UART_init(uint32_t Baudrate);

void USART3_IRQHandler(void);
void USART3_IRQHandler(void) {
  int UsartStatus;
  uint8_t v;

  UsartStatus = USART_SR;
  if (UsartStatus & (1 << USART_RXNE)) {  // Data received?
    v = USART_RDR;                        // Read data
    if ((UsartStatus & USART_RX_ERROR_FLAGS) == 0) {
      if (_cbOnRx) {
        _cbOnRx(v);
      }
    }
  }
  if (UsartStatus & (1 << USART_TXE)) {   // Tx (data register) empty
    if (_cbOnTx && _cbOnTx(&v) == 1) {
      USART_TDR = v;  // Transmit data
    } else {
      USART_CR1 &= ~(1UL << USART_TXEIE);  // Disable further TX interrupts
    }
  }
}

// Función de inicialización del UART
void HIF_UART_Init(uint32_t Baudrate, UART_ON_TX_FUNC_P cbOnTx, UART_ON_RX_FUNC_P cbOnRx) {
  uint32_t v;
  uint32_t Div;

  // Enable clocks
  RCC_APB1ENR |= (1 << 18);       // Enable USART3 clock
  RCC_AHB1ENR |= (1 << 3);        // Enable IO port D clock

  // Configure USART RX/TX pins for alternate function AF7
  v = GPIO_AFRH;
  v &= ~((15UL << ((GPIO_UART_TX_BIT - 8) << 2)) | (15UL << ((GPIO_UART_RX_BIT - 8) << 2)));
  v |= ((7UL << ((GPIO_UART_TX_BIT - 8) << 2)) | (7UL << ((GPIO_UART_RX_BIT - 8) << 2)));
  GPIO_AFRH = v;

  // Configure USART RX/TX pins for alternate function usage
  v = GPIO_MODER;
  v &= ~((3UL << (GPIO_UART_TX_BIT << 1)) | (3UL << (GPIO_UART_RX_BIT << 1)));
  v |= ((2UL << (GPIO_UART_TX_BIT << 1)) | (2UL << (GPIO_UART_RX_BIT << 1))); // PD8 y PD9 como función alternativa
  GPIO_MODER = v;

  // Configure USART
  USART_CR1 = (1 << 15) | (1 << 13) | (1 << 5) | (1 << 3) | (1 << 2); // Configuración básica
  USART_CR2 = 0;
  USART_CR3 = (1 << 7);

  // Set baud rate
  Div = (UART_BASECLK + (Baudrate / 2)) / Baudrate;
  USART_BRR = Div;

  // Set callbacks and enable NVIC interrupt
  _cbOnRx = cbOnRx;
  _cbOnTx = cbOnTx;
  NVIC_SetPriority(USART_IRQn, 6);
  NVIC_EnableIRQ(USART_IRQn);
}

// Función para habilitar la interrupción de transmisión
void HIF_UART_EnableTXEInterrupt(void) {
  USART_CR1 |= (1UL << USART_TXEIE);  // Habilita la interrupción de TX
}

// Función de inicialización del UART de SEGGER
void SEGGER_UART_init(uint32_t Baudrate) {
  HIF_UART_Init(Baudrate, _cbOnTx, _cbOnRx);
}




